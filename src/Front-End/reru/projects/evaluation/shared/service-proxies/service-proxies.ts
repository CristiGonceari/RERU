/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.3.0.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable({
    providedIn: 'root'
})
export class OptionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param questionUnitId (optional)
     * @return Success
     */
    getAll(questionUnitId: number | null | undefined): Observable<OptionsDto[]> {
        let url_ = this.baseUrl + "/api/Options/getAll?";
        if (questionUnitId !== undefined)
            url_ += "QuestionUnitId=" + encodeURIComponent("" + questionUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<OptionsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OptionsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<OptionsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OptionsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OptionsDto[]>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class ApiServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44356";
    }

    /**
     * @return Success
     */
    optionsGet(id: number): Observable<OptionsDto> {
        let url_ = this.baseUrl + "/api/Options/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOptionsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOptionsGet(<any>response_);
                } catch (e) {
                    return <Observable<OptionsDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OptionsDto>><any>_observableThrow(response_);
        }));
    }

    protected processOptionsGet(response: HttpResponseBase): Observable<OptionsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OptionsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OptionsDto>(<any>null);
    }

    /**
     * @return Success
     */
    optionsDelete(id: number): Observable<Unit> {
        let url_ = this.baseUrl + "/api/Options/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOptionsDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOptionsDelete(<any>response_);
                } catch (e) {
                    return <Observable<Unit>><any>_observableThrow(e);
                }
            } else
                return <Observable<Unit>><any>_observableThrow(response_);
        }));
    }

    protected processOptionsDelete(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Unit>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    optionsPost(body: CreateEditOptionsDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/Options";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOptionsPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOptionsPost(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processOptionsPost(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    optionsPatch(body: CreateEditOptionsDto | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/Options";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOptionsPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOptionsPatch(<any>response_);
                } catch (e) {
                    return <Observable<Unit>><any>_observableThrow(e);
                }
            } else
                return <Observable<Unit>><any>_observableThrow(response_);
        }));
    }

    protected processOptionsPatch(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Unit>(<any>null);
    }

    /**
     * @return Success
     */
    questionCategory(id: number): Observable<QuestionCategoryDto> {
        let url_ = this.baseUrl + "/api/QuestionCategory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQuestionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuestionCategory(<any>response_);
                } catch (e) {
                    return <Observable<QuestionCategoryDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionCategoryDto>><any>_observableThrow(response_);
        }));
    }

    protected processQuestionCategory(response: HttpResponseBase): Observable<QuestionCategoryDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionCategoryDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionCategoryDto>(<any>null);
    }

    /**
     * @return Success
     */
    questionUnitGet(id: number): Observable<QuestionUnitDto> {
        let url_ = this.baseUrl + "/api/QuestionUnit/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQuestionUnitGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuestionUnitGet(<any>response_);
                } catch (e) {
                    return <Observable<QuestionUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processQuestionUnitGet(response: HttpResponseBase): Observable<QuestionUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionUnitDto>(<any>null);
    }

    /**
     * @return Success
     */
    questionUnitDelete(id: number): Observable<Unit> {
        let url_ = this.baseUrl + "/api/QuestionUnit/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQuestionUnitDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuestionUnitDelete(<any>response_);
                } catch (e) {
                    return <Observable<Unit>><any>_observableThrow(e);
                }
            } else
                return <Observable<Unit>><any>_observableThrow(response_);
        }));
    }

    protected processQuestionUnitDelete(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Unit>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    questionUnitPost(body: CreateEditQuestionUnitDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/QuestionUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQuestionUnitPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuestionUnitPost(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processQuestionUnitPost(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    questionUnitPatch(body: CreateEditQuestionUnitDto | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/QuestionUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQuestionUnitPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQuestionUnitPatch(<any>response_);
                } catch (e) {
                    return <Observable<Unit>><any>_observableThrow(e);
                }
            } else
                return <Observable<Unit>><any>_observableThrow(response_);
        }));
    }

    protected processQuestionUnitPatch(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Unit>(<any>null);
    }

    /**
     * @return Success
     */
    test(): Observable<string> {
        let url_ = this.baseUrl + "/api/Test";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTest(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processTest(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    testsPost(body: CreateTestCommand | undefined): Observable<Int32Response> {
        let url_ = this.baseUrl + "/api/Tests";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestsPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestsPost(<any>response_);
                } catch (e) {
                    return <Observable<Int32Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int32Response>><any>_observableThrow(response_);
        }));
    }

    protected processTestsPost(response: HttpResponseBase): Observable<Int32Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int32Response>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    testsPatch(body: UpdateTestCommand | undefined): Observable<Int32Response> {
        let url_ = this.baseUrl + "/api/Tests";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestsPatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestsPatch(<any>response_);
                } catch (e) {
                    return <Observable<Int32Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int32Response>><any>_observableThrow(response_);
        }));
    }

    protected processTestsPatch(response: HttpResponseBase): Observable<Int32Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int32Response>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    testsGet(id: number | undefined): Observable<TestDtoResponse> {
        let url_ = this.baseUrl + "/api/Tests?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestsGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestsGet(<any>response_);
                } catch (e) {
                    return <Observable<TestDtoResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<TestDtoResponse>><any>_observableThrow(response_);
        }));
    }

    protected processTestsGet(response: HttpResponseBase): Observable<TestDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TestDtoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TestDtoResponse>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    testTypePost(body: CreateTestTypeCommand | undefined): Observable<Int32Response> {
        let url_ = this.baseUrl + "/api/TestType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestTypePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestTypePost(<any>response_);
                } catch (e) {
                    return <Observable<Int32Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int32Response>><any>_observableThrow(response_);
        }));
    }

    protected processTestTypePost(response: HttpResponseBase): Observable<Int32Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int32Response>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    testTypePatch(body: UpdateTestTypeCommand | undefined): Observable<Int32Response> {
        let url_ = this.baseUrl + "/api/TestType";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestTypePatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestTypePatch(<any>response_);
                } catch (e) {
                    return <Observable<Int32Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int32Response>><any>_observableThrow(response_);
        }));
    }

    protected processTestTypePatch(response: HttpResponseBase): Observable<Int32Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int32Response>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    testTypeGet(id: number | undefined): Observable<TestTypeDtoResponse> {
        let url_ = this.baseUrl + "/api/TestType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestTypeGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestTypeGet(<any>response_);
                } catch (e) {
                    return <Observable<TestTypeDtoResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<TestTypeDtoResponse>><any>_observableThrow(response_);
        }));
    }

    protected processTestTypeGet(response: HttpResponseBase): Observable<TestTypeDtoResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TestTypeDtoResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TestTypeDtoResponse>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    testTypeDelete(id: number | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/api/TestType?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestTypeDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestTypeDelete(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processTestTypeDelete(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    testTypeQuestionCategoryPost(body: AssignQuestionCategoryToTestTypeCommand | undefined): Observable<Int32Response> {
        let url_ = this.baseUrl + "/api/TestTypeQuestionCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestTypeQuestionCategoryPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestTypeQuestionCategoryPost(<any>response_);
                } catch (e) {
                    return <Observable<Int32Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Int32Response>><any>_observableThrow(response_);
        }));
    }

    protected processTestTypeQuestionCategoryPost(response: HttpResponseBase): Observable<Int32Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Int32Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Int32Response>(<any>null);
    }

    /**
     * @param testTypeId (optional)
     * @return Success
     */
    testTypeQuestionCategoryGet(testTypeId: number | null | undefined): Observable<QuestionCategoriesByTestTypeIdDtoListResponse> {
        let url_ = this.baseUrl + "/api/TestTypeQuestionCategory?";
        if (testTypeId !== undefined)
            url_ += "TestTypeId=" + encodeURIComponent("" + testTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestTypeQuestionCategoryGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestTypeQuestionCategoryGet(<any>response_);
                } catch (e) {
                    return <Observable<QuestionCategoriesByTestTypeIdDtoListResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionCategoriesByTestTypeIdDtoListResponse>><any>_observableThrow(response_);
        }));
    }

    protected processTestTypeQuestionCategoryGet(response: HttpResponseBase): Observable<QuestionCategoriesByTestTypeIdDtoListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionCategoriesByTestTypeIdDtoListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionCategoriesByTestTypeIdDtoListResponse>(<any>null);
    }

    /**
     * @param id (optional)
     * @return Success
     */
    testTypeQuestionCategoryDelete(id: number | undefined): Observable<Response> {
        let url_ = this.baseUrl + "/api/TestTypeQuestionCategory?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestTypeQuestionCategoryDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestTypeQuestionCategoryDelete(<any>response_);
                } catch (e) {
                    return <Observable<Response>><any>_observableThrow(e);
                }
            } else
                return <Observable<Response>><any>_observableThrow(response_);
        }));
    }

    protected processTestTypeQuestionCategoryDelete(response: HttpResponseBase): Observable<Response> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Response.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Response>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class QuestionCategoryServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional)
     * @return Success
     */
    getAll(filter: string | null | undefined): Observable<QuestionCategoryDto[]> {
        let url_ = this.baseUrl + "/api/QuestionCategory/getAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<QuestionCategoryDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionCategoryDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<QuestionCategoryDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(QuestionCategoryDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionCategoryDto[]>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    create(body: CreateEditQuestionCategoryDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/QuestionCategory/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param body (optional)
     * @return Success
     */
    edit(body: CreateEditQuestionCategoryDto | undefined): Observable<Unit> {
        let url_ = this.baseUrl + "/api/QuestionCategory/edit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEdit(<any>response_);
                } catch (e) {
                    return <Observable<Unit>><any>_observableThrow(e);
                }
            } else
                return <Observable<Unit>><any>_observableThrow(response_);
        }));
    }

    protected processEdit(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Unit>(<any>null);
    }

    /**
     * @return Success
     */
    delete(id: number): Observable<Unit> {
        let url_ = this.baseUrl + "/api/QuestionCategory/delete/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<Unit>><any>_observableThrow(e);
                }
            } else
                return <Observable<Unit>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<Unit> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Unit.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Unit>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class QuestionUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param questionCategoryId (optional)
     * @return Success
     */
    getAll(questionCategoryId: number | null | undefined): Observable<QuestionUnitDto[]> {
        let url_ = this.baseUrl + "/api/QuestionUnit/getAll?";
        if (questionCategoryId !== undefined)
            url_ += "QuestionCategoryId=" + encodeURIComponent("" + questionCategoryId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<QuestionUnitDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionUnitDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<QuestionUnitDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(QuestionUnitDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionUnitDto[]>(<any>null);
    }

    /**
     * @return Success
     */
    forTest(id: number): Observable<QuestionUnitDto> {
        let url_ = this.baseUrl + "/api/QuestionUnit/forTest/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForTest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForTest(<any>response_);
                } catch (e) {
                    return <Observable<QuestionUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuestionUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processForTest(response: HttpResponseBase): Observable<QuestionUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuestionUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuestionUnitDto>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TestTypeStatusesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44356";
    }

    /**
     * @return Success
     */
    selectValues(): Observable<SelectItemListResponse> {
        let url_ = this.baseUrl + "/api/Reference/test-type-statuses/select-values";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectValues(<any>response_);
                } catch (e) {
                    return <Observable<SelectItemListResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectItemListResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSelectValues(response: HttpResponseBase): Observable<SelectItemListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectItemListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectItemListResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class QuestionTypesValueServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44356";
    }

    /**
     * @return Success
     */
    selectValues(): Observable<SelectItemListResponse> {
        let url_ = this.baseUrl + "/api/Reference/question-types-value/select-values";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectValues(<any>response_);
                } catch (e) {
                    return <Observable<SelectItemListResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectItemListResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSelectValues(response: HttpResponseBase): Observable<SelectItemListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectItemListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectItemListResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class QuestionCategoriesValueServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44356";
    }

    /**
     * @return Success
     */
    selectValues(): Observable<SelectItemListResponse> {
        let url_ = this.baseUrl + "/api/Reference/question-categories-value/select-values";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSelectValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSelectValues(<any>response_);
                } catch (e) {
                    return <Observable<SelectItemListResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<SelectItemListResponse>><any>_observableThrow(response_);
        }));
    }

    protected processSelectValues(response: HttpResponseBase): Observable<SelectItemListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SelectItemListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SelectItemListResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TestsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param testTypeId (optional)
     * @return Success
     */
    getAll(testTypeId: number | null | undefined): Observable<TestDtoListResponse> {
        let url_ = this.baseUrl + "/api/Tests/getAll?";
        if (testTypeId !== undefined)
            url_ += "TestTypeId=" + encodeURIComponent("" + testTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<TestDtoListResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<TestDtoListResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<TestDtoListResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TestDtoListResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TestDtoListResponse>(<any>null);
    }
}

@Injectable({
    providedIn: 'root'
})
export class TestTypeServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44356";
    }

    /**
     * @param name (optional)
     * @param status (optional)
     * @param page (optional)
     * @param itemsPerPage (optional)
     * @param orderField (optional)
     * @param fields (optional)
     * @param searchBy (optional)
     * @return Success
     */
    list(name: string | null | undefined, status: number | null | undefined, page: number | undefined, itemsPerPage: number | undefined, orderField: string | null | undefined, fields: string | null | undefined, searchBy: string | null | undefined): Observable<TestTypeDtoPaginatedModelResponse> {
        let url_ = this.baseUrl + "/api/TestType/list?";
        if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (itemsPerPage === null)
            throw new Error("The parameter 'itemsPerPage' cannot be null.");
        else if (itemsPerPage !== undefined)
            url_ += "ItemsPerPage=" + encodeURIComponent("" + itemsPerPage) + "&";
        if (orderField !== undefined)
            url_ += "OrderField=" + encodeURIComponent("" + orderField) + "&";
        if (fields !== undefined)
            url_ += "Fields=" + encodeURIComponent("" + fields) + "&";
        if (searchBy !== undefined)
            url_ += "SearchBy=" + encodeURIComponent("" + searchBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(<any>response_);
                } catch (e) {
                    return <Observable<TestTypeDtoPaginatedModelResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<TestTypeDtoPaginatedModelResponse>><any>_observableThrow(response_);
        }));
    }

    protected processList(response: HttpResponseBase): Observable<TestTypeDtoPaginatedModelResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TestTypeDtoPaginatedModelResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TestTypeDtoPaginatedModelResponse>(<any>null);
    }
}

export class OptionsDto implements IOptionsDto {
    id!: number;
    questionUnitId!: number;
    answer!: string | undefined;
    isCorrect!: boolean | undefined;

    constructor(data?: IOptionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionUnitId = _data["questionUnitId"];
            this.answer = _data["answer"];
            this.isCorrect = _data["isCorrect"];
        }
    }

    static fromJS(data: any): OptionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new OptionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionUnitId"] = this.questionUnitId;
        data["answer"] = this.answer;
        data["isCorrect"] = this.isCorrect;
        return data;
    }
}

export interface IOptionsDto {
    id: number;
    questionUnitId: number;
    answer: string | undefined;
    isCorrect: boolean | undefined;
}

export class Unit implements IUnit {

    constructor(data?: IUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Unit {
        data = typeof data === 'object' ? data : {};
        let result = new Unit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface IUnit {
}

export class CreateEditOptionsDto implements ICreateEditOptionsDto {
    id!: number | undefined;
    questionUnitId!: number;
    answer!: string | undefined;
    isCorrect!: boolean;

    constructor(data?: ICreateEditOptionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionUnitId = _data["questionUnitId"];
            this.answer = _data["answer"];
            this.isCorrect = _data["isCorrect"];
        }
    }

    static fromJS(data: any): CreateEditOptionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEditOptionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionUnitId"] = this.questionUnitId;
        data["answer"] = this.answer;
        data["isCorrect"] = this.isCorrect;
        return data;
    }
}

export interface ICreateEditOptionsDto {
    id: number | undefined;
    questionUnitId: number;
    answer: string | undefined;
    isCorrect: boolean;
}

export enum QuestionTypeEnum {
    _0 = 0,
    _1 = 1,
    _2 = 2,
    _3 = 3,
}

export class QuestionUnitDto implements IQuestionUnitDto {
    id!: number;
    questionCategoryId!: number;
    question!: string | undefined;
    questionType!: QuestionTypeEnum;
    options!: OptionsDto[] | undefined;

    constructor(data?: IQuestionUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionCategoryId = _data["questionCategoryId"];
            this.question = _data["question"];
            this.questionType = _data["questionType"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(OptionsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionCategoryId"] = this.questionCategoryId;
        data["question"] = this.question;
        data["questionType"] = this.questionType;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuestionUnitDto {
    id: number;
    questionCategoryId: number;
    question: string | undefined;
    questionType: QuestionTypeEnum;
    options: OptionsDto[] | undefined;
}

export class QuestionCategoryDto implements IQuestionCategoryDto {
    id!: number;
    name!: string | undefined;
    questionUnits!: QuestionUnitDto[] | undefined;

    constructor(data?: IQuestionCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["questionUnits"])) {
                this.questionUnits = [] as any;
                for (let item of _data["questionUnits"])
                    this.questionUnits!.push(QuestionUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.questionUnits)) {
            data["questionUnits"] = [];
            for (let item of this.questionUnits)
                data["questionUnits"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuestionCategoryDto {
    id: number;
    name: string | undefined;
    questionUnits: QuestionUnitDto[] | undefined;
}

export class CreateEditQuestionCategoryDto implements ICreateEditQuestionCategoryDto {
    id!: number | undefined;
    name!: string | undefined;

    constructor(data?: ICreateEditQuestionCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateEditQuestionCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEditQuestionCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface ICreateEditQuestionCategoryDto {
    id: number | undefined;
    name: string | undefined;
}

export class CreateEditQuestionUnitDto implements ICreateEditQuestionUnitDto {
    id!: number | undefined;
    questionCategoryId!: number;
    question!: string | undefined;
    questionType!: QuestionTypeEnum;

    constructor(data?: ICreateEditQuestionUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.questionCategoryId = _data["questionCategoryId"];
            this.question = _data["question"];
            this.questionType = _data["questionType"];
        }
    }

    static fromJS(data: any): CreateEditQuestionUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEditQuestionUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["questionCategoryId"] = this.questionCategoryId;
        data["question"] = this.question;
        data["questionType"] = this.questionType;
        return data;
    }
}

export interface ICreateEditQuestionUnitDto {
    id: number | undefined;
    questionCategoryId: number;
    question: string | undefined;
    questionType: QuestionTypeEnum;
}

export class SelectItem implements ISelectItem {
    value!: string | undefined;
    label!: string | undefined;

    constructor(data?: ISelectItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): SelectItem {
        data = typeof data === 'object' ? data : {};
        let result = new SelectItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["label"] = this.label;
        return data;
    }
}

export interface ISelectItem {
    value: string | undefined;
    label: string | undefined;
}

export enum MessageType {
    _1 = 1,
    _2 = 2,
    _3 = 3,
    _4 = 4,
    _5 = 5,
    _6 = 6,
}

export class StringObjectKeyValuePair implements IStringObjectKeyValuePair {
    readonly key!: string | undefined;
    readonly value!: any | undefined;

    constructor(data?: IStringObjectKeyValuePair) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).key = _data["key"];
            (<any>this).value = _data["value"];
        }
    }

    static fromJS(data: any): StringObjectKeyValuePair {
        data = typeof data === 'object' ? data : {};
        let result = new StringObjectKeyValuePair();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IStringObjectKeyValuePair {
    key: string | undefined;
    value: any | undefined;
}

export class Message implements IMessage {
    code!: string | undefined;
    messageText!: string | undefined;
    type!: MessageType;
    data!: StringObjectKeyValuePair[] | undefined;

    constructor(data?: IMessage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.messageText = _data["messageText"];
            this.type = _data["type"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(StringObjectKeyValuePair.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Message {
        data = typeof data === 'object' ? data : {};
        let result = new Message();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["messageText"] = this.messageText;
        data["type"] = this.type;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMessage {
    code: string | undefined;
    messageText: string | undefined;
    type: MessageType;
    data: StringObjectKeyValuePair[] | undefined;
}

export class SelectItemListResponse implements ISelectItemListResponse {
    data!: SelectItem[] | undefined;
    success!: boolean;
    readonly messages!: Message[] | undefined;

    constructor(data?: ISelectItemListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(SelectItem.fromJS(item));
            }
            this.success = _data["success"];
            if (Array.isArray(_data["messages"])) {
                (<any>this).messages = [] as any;
                for (let item of _data["messages"])
                    (<any>this).messages!.push(Message.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SelectItemListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SelectItemListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["success"] = this.success;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISelectItemListResponse {
    data: SelectItem[] | undefined;
    success: boolean;
    messages: Message[] | undefined;
}

export class CreateUpdateTestDto implements ICreateUpdateTestDto {
    id!: number;
    dateTime!: Date;
    userId!: number;
    testTypeId!: number;

    constructor(data?: ICreateUpdateTestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.testTypeId = _data["testTypeId"];
        }
    }

    static fromJS(data: any): CreateUpdateTestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateTestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["testTypeId"] = this.testTypeId;
        return data;
    }
}

export interface ICreateUpdateTestDto {
    id: number;
    dateTime: Date;
    userId: number;
    testTypeId: number;
}

export class CreateTestCommand implements ICreateTestCommand {
    input!: CreateUpdateTestDto;

    constructor(data?: ICreateTestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.input = _data["input"] ? CreateUpdateTestDto.fromJS(_data["input"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateTestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["input"] = this.input ? this.input.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateTestCommand {
    input: CreateUpdateTestDto;
}

export class Int32Response implements IInt32Response {
    data!: number;
    success!: boolean;
    readonly messages!: Message[] | undefined;

    constructor(data?: IInt32Response) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"];
            this.success = _data["success"];
            if (Array.isArray(_data["messages"])) {
                (<any>this).messages = [] as any;
                for (let item of _data["messages"])
                    (<any>this).messages!.push(Message.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Int32Response {
        data = typeof data === 'object' ? data : {};
        let result = new Int32Response();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data;
        data["success"] = this.success;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInt32Response {
    data: number;
    success: boolean;
    messages: Message[] | undefined;
}

export class UpdateTestCommand implements IUpdateTestCommand {
    input!: CreateUpdateTestDto;

    constructor(data?: IUpdateTestCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.input = _data["input"] ? CreateUpdateTestDto.fromJS(_data["input"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateTestCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTestCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["input"] = this.input ? this.input.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateTestCommand {
    input: CreateUpdateTestDto;
}

export class TestDto implements ITestDto {
    id!: number;
    dateTime!: Date;
    userId!: number;
    testTypeId!: number;

    constructor(data?: ITestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.userId = _data["userId"];
            this.testTypeId = _data["testTypeId"];
        }
    }

    static fromJS(data: any): TestDto {
        data = typeof data === 'object' ? data : {};
        let result = new TestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["userId"] = this.userId;
        data["testTypeId"] = this.testTypeId;
        return data;
    }
}

export interface ITestDto {
    id: number;
    dateTime: Date;
    userId: number;
    testTypeId: number;
}

export class TestDtoResponse implements ITestDtoResponse {
    data!: TestDto;
    success!: boolean;
    readonly messages!: Message[] | undefined;

    constructor(data?: ITestDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? TestDto.fromJS(_data["data"]) : <any>undefined;
            this.success = _data["success"];
            if (Array.isArray(_data["messages"])) {
                (<any>this).messages = [] as any;
                for (let item of _data["messages"])
                    (<any>this).messages!.push(Message.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TestDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TestDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITestDtoResponse {
    data: TestDto;
    success: boolean;
    messages: Message[] | undefined;
}

export class TestDtoListResponse implements ITestDtoListResponse {
    data!: TestDto[] | undefined;
    success!: boolean;
    readonly messages!: Message[] | undefined;

    constructor(data?: ITestDtoListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(TestDto.fromJS(item));
            }
            this.success = _data["success"];
            if (Array.isArray(_data["messages"])) {
                (<any>this).messages = [] as any;
                for (let item of _data["messages"])
                    (<any>this).messages!.push(Message.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TestDtoListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TestDtoListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["success"] = this.success;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITestDtoListResponse {
    data: TestDto[] | undefined;
    success: boolean;
    messages: Message[] | undefined;
}

export enum TestTypeStatusEnum {
    _0 = 0,
    _1 = 1,
    _2 = 2,
}

export class CreateUpdateTestTypeDto implements ICreateUpdateTestTypeDto {
    id!: number;
    name!: string | undefined;
    questionCount!: number;
    minScore!: number;
    status!: TestTypeStatusEnum;

    constructor(data?: ICreateUpdateTestTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.questionCount = _data["questionCount"];
            this.minScore = _data["minScore"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): CreateUpdateTestTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUpdateTestTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["questionCount"] = this.questionCount;
        data["minScore"] = this.minScore;
        data["status"] = this.status;
        return data;
    }
}

export interface ICreateUpdateTestTypeDto {
    id: number;
    name: string | undefined;
    questionCount: number;
    minScore: number;
    status: TestTypeStatusEnum;
}

export class CreateTestTypeCommand implements ICreateTestTypeCommand {
    input!: CreateUpdateTestTypeDto;

    constructor(data?: ICreateTestTypeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.input = _data["input"] ? CreateUpdateTestTypeDto.fromJS(_data["input"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateTestTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTestTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["input"] = this.input ? this.input.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateTestTypeCommand {
    input: CreateUpdateTestTypeDto;
}

export class UpdateTestTypeCommand implements IUpdateTestTypeCommand {
    input!: CreateUpdateTestTypeDto;

    constructor(data?: IUpdateTestTypeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.input = _data["input"] ? CreateUpdateTestTypeDto.fromJS(_data["input"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UpdateTestTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTestTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["input"] = this.input ? this.input.toJSON() : <any>undefined;
        return data;
    }
}

export interface IUpdateTestTypeCommand {
    input: CreateUpdateTestTypeDto;
}

export class TestTypeDto implements ITestTypeDto {
    id!: number;
    name!: string | undefined;
    questionCount!: number;
    minScore!: number;
    categoriesCount!: number;
    status!: TestTypeStatusEnum;

    constructor(data?: ITestTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.questionCount = _data["questionCount"];
            this.minScore = _data["minScore"];
            this.categoriesCount = _data["categoriesCount"];
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): TestTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new TestTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["questionCount"] = this.questionCount;
        data["minScore"] = this.minScore;
        data["categoriesCount"] = this.categoriesCount;
        data["status"] = this.status;
        return data;
    }
}

export interface ITestTypeDto {
    id: number;
    name: string | undefined;
    questionCount: number;
    minScore: number;
    categoriesCount: number;
    status: TestTypeStatusEnum;
}

export class TestTypeDtoResponse implements ITestTypeDtoResponse {
    data!: TestTypeDto;
    success!: boolean;
    readonly messages!: Message[] | undefined;

    constructor(data?: ITestTypeDtoResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? TestTypeDto.fromJS(_data["data"]) : <any>undefined;
            this.success = _data["success"];
            if (Array.isArray(_data["messages"])) {
                (<any>this).messages = [] as any;
                for (let item of _data["messages"])
                    (<any>this).messages!.push(Message.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TestTypeDtoResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TestTypeDtoResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITestTypeDtoResponse {
    data: TestTypeDto;
    success: boolean;
    messages: Message[] | undefined;
}

export class Response implements IResponse {
    success!: boolean;
    readonly messages!: Message[] | undefined;

    constructor(data?: IResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
            if (Array.isArray(_data["messages"])) {
                (<any>this).messages = [] as any;
                for (let item of _data["messages"])
                    (<any>this).messages!.push(Message.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Response {
        data = typeof data === 'object' ? data : {};
        let result = new Response();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponse {
    success: boolean;
    messages: Message[] | undefined;
}

export class PaginatedHeaderParameter implements IPaginatedHeaderParameter {
    totalCount!: number;
    pageSize!: number;
    currentPage!: number;
    readonly totalPages!: number;

    constructor(data?: IPaginatedHeaderParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.pageSize = _data["pageSize"];
            this.currentPage = _data["currentPage"];
            (<any>this).totalPages = _data["totalPages"];
        }
    }

    static fromJS(data: any): PaginatedHeaderParameter {
        data = typeof data === 'object' ? data : {};
        let result = new PaginatedHeaderParameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["pageSize"] = this.pageSize;
        data["currentPage"] = this.currentPage;
        data["totalPages"] = this.totalPages;
        return data;
    }
}

export interface IPaginatedHeaderParameter {
    totalCount: number;
    pageSize: number;
    currentPage: number;
    totalPages: number;
}

export class TestTypeDtoPaginatedModel implements ITestTypeDtoPaginatedModel {
    items!: TestTypeDto[] | undefined;
    pagedSummary!: PaginatedHeaderParameter;

    constructor(data?: ITestTypeDtoPaginatedModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TestTypeDto.fromJS(item));
            }
            this.pagedSummary = _data["pagedSummary"] ? PaginatedHeaderParameter.fromJS(_data["pagedSummary"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TestTypeDtoPaginatedModel {
        data = typeof data === 'object' ? data : {};
        let result = new TestTypeDtoPaginatedModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pagedSummary"] = this.pagedSummary ? this.pagedSummary.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITestTypeDtoPaginatedModel {
    items: TestTypeDto[] | undefined;
    pagedSummary: PaginatedHeaderParameter;
}

export class TestTypeDtoPaginatedModelResponse implements ITestTypeDtoPaginatedModelResponse {
    data!: TestTypeDtoPaginatedModel;
    success!: boolean;
    readonly messages!: Message[] | undefined;

    constructor(data?: ITestTypeDtoPaginatedModelResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.data = _data["data"] ? TestTypeDtoPaginatedModel.fromJS(_data["data"]) : <any>undefined;
            this.success = _data["success"];
            if (Array.isArray(_data["messages"])) {
                (<any>this).messages = [] as any;
                for (let item of _data["messages"])
                    (<any>this).messages!.push(Message.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TestTypeDtoPaginatedModelResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TestTypeDtoPaginatedModelResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["success"] = this.success;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ITestTypeDtoPaginatedModelResponse {
    data: TestTypeDtoPaginatedModel;
    success: boolean;
    messages: Message[] | undefined;
}

export class AssignQuestionCategoryToTestTypeDto implements IAssignQuestionCategoryToTestTypeDto {
    testTypeId!: number;
    questionCategoryId!: number;
    questionType!: QuestionTypeEnum;
    questionCount!: number | undefined;

    constructor(data?: IAssignQuestionCategoryToTestTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.testTypeId = _data["testTypeId"];
            this.questionCategoryId = _data["questionCategoryId"];
            this.questionType = _data["questionType"];
            this.questionCount = _data["questionCount"];
        }
    }

    static fromJS(data: any): AssignQuestionCategoryToTestTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssignQuestionCategoryToTestTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["testTypeId"] = this.testTypeId;
        data["questionCategoryId"] = this.questionCategoryId;
        data["questionType"] = this.questionType;
        data["questionCount"] = this.questionCount;
        return data;
    }
}

export interface IAssignQuestionCategoryToTestTypeDto {
    testTypeId: number;
    questionCategoryId: number;
    questionType: QuestionTypeEnum;
    questionCount: number | undefined;
}

export class AssignQuestionCategoryToTestTypeCommand implements IAssignQuestionCategoryToTestTypeCommand {
    input!: AssignQuestionCategoryToTestTypeDto;

    constructor(data?: IAssignQuestionCategoryToTestTypeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.input = _data["input"] ? AssignQuestionCategoryToTestTypeDto.fromJS(_data["input"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AssignQuestionCategoryToTestTypeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AssignQuestionCategoryToTestTypeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["input"] = this.input ? this.input.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAssignQuestionCategoryToTestTypeCommand {
    input: AssignQuestionCategoryToTestTypeDto;
}

export class QuestionCategoriesByTestTypeIdDto implements IQuestionCategoriesByTestTypeIdDto {
    id!: number;
    testTypeId!: number;
    questionCategoryId!: number;
    questionCategoryName!: string | undefined;
    questionType!: QuestionTypeEnum;
    questionCount!: number | undefined;

    constructor(data?: IQuestionCategoriesByTestTypeIdDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.testTypeId = _data["testTypeId"];
            this.questionCategoryId = _data["questionCategoryId"];
            this.questionCategoryName = _data["questionCategoryName"];
            this.questionType = _data["questionType"];
            this.questionCount = _data["questionCount"];
        }
    }

    static fromJS(data: any): QuestionCategoriesByTestTypeIdDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionCategoriesByTestTypeIdDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["testTypeId"] = this.testTypeId;
        data["questionCategoryId"] = this.questionCategoryId;
        data["questionCategoryName"] = this.questionCategoryName;
        data["questionType"] = this.questionType;
        data["questionCount"] = this.questionCount;
        return data;
    }
}

export interface IQuestionCategoriesByTestTypeIdDto {
    id: number;
    testTypeId: number;
    questionCategoryId: number;
    questionCategoryName: string | undefined;
    questionType: QuestionTypeEnum;
    questionCount: number | undefined;
}

export class QuestionCategoriesByTestTypeIdDtoListResponse implements IQuestionCategoriesByTestTypeIdDtoListResponse {
    data!: QuestionCategoriesByTestTypeIdDto[] | undefined;
    success!: boolean;
    readonly messages!: Message[] | undefined;

    constructor(data?: IQuestionCategoriesByTestTypeIdDtoListResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(QuestionCategoriesByTestTypeIdDto.fromJS(item));
            }
            this.success = _data["success"];
            if (Array.isArray(_data["messages"])) {
                (<any>this).messages = [] as any;
                for (let item of _data["messages"])
                    (<any>this).messages!.push(Message.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuestionCategoriesByTestTypeIdDtoListResponse {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionCategoriesByTestTypeIdDtoListResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["success"] = this.success;
        if (Array.isArray(this.messages)) {
            data["messages"] = [];
            for (let item of this.messages)
                data["messages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQuestionCategoriesByTestTypeIdDtoListResponse {
    data: QuestionCategoriesByTestTypeIdDto[] | undefined;
    success: boolean;
    messages: Message[] | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
